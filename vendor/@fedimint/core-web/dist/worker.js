globalThis.__vitest_browser_runner__={wrapDynamicImport:e=>e()};let e=null,s=null;const t=new Map;console.log("Worker - init"),self.onmessage=async o=>{const{type:r,payload:a,requestId:n}=o.data;try{if("init"===r)e=(await import("@fedimint/fedimint-client-wasm-bundler")).WasmClient,self.postMessage({type:"initialized",data:{},requestId:n});else if("open"===r){const{clientName:t}=a;s=await e.open(t)||null,self.postMessage({type:"open",data:{success:!!s},requestId:n})}else if("join"===r){const{inviteCode:t,clientName:o}=a;try{s=await e.join_federation(o,t),self.postMessage({type:"join",data:{success:!!s},requestId:n})}catch(e){self.postMessage({type:"error",error:e.message,requestId:n})}}else if("rpc"===r){const{module:e,method:o,body:r}=a;if(console.log("RPC received",e,o,r),!s)return void self.postMessage({type:"error",error:"WasmClient not initialized",requestId:n});const i=await s.rpc(e,o,JSON.stringify(r),(e=>{console.log("RPC response",n,e);const s=JSON.parse(e);if(self.postMessage({type:"rpcResponse",requestId:n,...s}),void 0!==s.end){const e=t.get(n);e?.free()}}));t.set(n,i)}else if("unsubscribe"===r){const e=t.get(n);e&&(e.cancel(),e.free(),t.delete(n))}else if("cleanup"===r)console.log("cleanup message received"),s?.free(),self.postMessage({type:"cleanup",data:{},requestId:n}),close();else if("parse"===r){const{inviteCode:s}=a,t=await e.parse_invite_code(s);self.postMessage({type:"parse",data:t,requestId:n})}else self.postMessage({type:"error",error:"Unknown message type",requestId:n})}catch(e){console.error("ERROR",e),self.postMessage({type:"error",error:e,requestId:n})}};
//# sourceMappingURL=worker.js.map
